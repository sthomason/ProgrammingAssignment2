## This function takes as its input a matrix that has been 
## saved as a separate object (i.e. a <- matrix(1:6, 2, 3))
## and creates a "special matrix", or list of functions to 
## (1) set the value of the matrix
## (2) get the value of the matrix
## (3) set the value of the inverse of the matrix
## (4) get the value of the inverse of the matrix

makeCacheMatrix <- function(x = matrix()) {
        m <- NULL
        set <- function(y, z, q) {
                x <<- matrix(y, z, q)
                x <<- as.data.frame(x)
                m <<- NULL
        }
        get <- function() x
        setsolve <- function(solve) m <<- solve
        getsolve <- function() m
        list(set = set, get = get,
             setsolve = setsolve,
             getsolve = getsolve)
}


## This function takes as its input the "special matrix"
## generated by the first function above. For example, after
## creating matrix a, you would then create a new object
## with makeCacheSolve (i.e. b <- makeCacheMatrix(a)) and 
## use b as the input for this function (i.e cacheSolve(b)) 

## This function checks to see if the inverse of the
## matrix has already been calculated. If it has, it
## gets the inverse matrix from the cache. Otherwise,
## it calculates the inverse matrix and saves it in 
## the cache.

## If the matrix is singular and does not have an inverse,
## the function returns a message saying "singular
## matrix, does not have an inverse"

cacheSolve <- function(x, ...) {
        m <- x$getsolve()
        if(!is.null(m)) {
                message("getting cached data")
                return(m)
        }
        data <- x$get()
        n <- function(f) {
        tryCatch(solve(f, ...), error = function(p) {print("singular matrix, does not have an inverse")}
        )
        }
        m <- n(data)
        x$setsolve(m)
        m
}
